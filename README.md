# Instructions
To build:
```sh
$ cargo build --release
```

To use:
```sh
$ ETHERSCAN_API_KEY=... ./target/release/wallet_classifier 0xdadb0d80178819f2319190d340ce9a924f783711 0x870585e3af9da7ff5dcd8f897ea0756f60f69cc1 0xa489faf6e337d997b8a23e2b6f3a8880b1b61e19
address                                         class
0xdadb0d80178819f2319190d340ce9a924f783711      customer (82.5%)
0x870585e3af9da7ff5dcd8f897ea0756f60f69cc1      customer (81.0%)
0xa489faf6e337d997b8a23e2b6f3a8880b1b61e19      contract (100.0%)
```

# Improvement ideas
- Add a feature for number of interactions with contracts (like with number of interactions with exchanges).
- More training data, not only based on labeled data but also heuristics.
- More heuristics, to, for example, detect miners/validators.
- In-memory caching for the etherscan api.

# Data (in data.zip)
### `exchanges.csv`
Contains a list of known exchange-owned wallets according to a dune query I found (which is use to label wallets on etherscan).

### `exchanges_with_trades.csv`
Contains a list of known exchange-owned wallets and their number of trades and volume.

### `customer.csv`
Contains a list of random wallets, likely to be customers, scraped via rpc by taking random transactions in random blocks.

### `bots.csv`
Contains a list of mev-bot-owned wallets, scraped from etherscan.

### `all_features.csv`
Contains a list of wallets and features. Generated by src/scrape.rs.

### `all_classified.csv`
Contains a list of wallets and their labels. Generated by classify_all.py.

# Code
### `classify_all.py`
Classifies exchanges as hot or cold based on trade count and volume and bots and customers.

### `train.py`
Trains a RF model on all_features.csv. Creates rf_model.joblib.

### `src/scrape.rs`
Used to scrape data and calculate features for the list of addresses in all_classified.csv.

### `src/main.rs`
Used for class prediction. Takes wallets as command line arguments and outputs the predicted class for each one.

### `src/wallet_classifier.rs`
Calculates features for a wallet and runs a python interpreter to use the RF model to predict the class.

### `src/etherscan.rs`
Interacts with the etherscan api. The reason I'm using the etherscan api instead of raw rpc is because fetching transactions for a wallet would take ages since it'd be a linear scan.
